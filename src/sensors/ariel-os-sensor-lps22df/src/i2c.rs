//! Driver for the sensor used over I2C.

use ariel_os_sensors::{
    Category, Label, MeasurementUnit, Sensor,
    sensor::{
        Mode as SensorMode, ReadingChannel, ReadingChannels, ReadingError, ReadingResult,
        ReadingWaiter, Sample, Samples, SetModeError, State, TriggerMeasurementError,
    },
    signal::Signal as ReadingSignal,
};
use ariel_os_sensors_utils::AtomicState;
use embassy_sync::{
    blocking_mutex::raw::CriticalSectionRawMutex, mutex::Mutex, once_lock::OnceLock, signal::Signal,
};
use embassy_time::Timer;
use embedded_hal_async::i2c::I2c;
use portable_atomic::{AtomicI16, AtomicU8, Ordering};

use crate::{PART_NUMBER, Register, i32_from_i24_be_bytes};

/// I2C address of the sensor device.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
pub enum I2cAddress {
    /// The SA0 pin is pulled low.
    Sa0Gnd = 0x5c,
    /// The SA0 pin is pulled high.
    // No internal pull resistor on the SA0 pin, we pick an arbitrary default value.
    #[default]
    Sa0Vdd = 0x5d,
}

/// Configuration of the sensor driver and device.
#[derive(Debug, Default)]
#[non_exhaustive]
pub struct Config {
    /// I2C address to use.
    pub address: I2cAddress,
}

ariel_os_hal::define_peripherals!(
    /// Peripherals required by the sensor driver.
    Peripherals {}
);

/// Driver to use an LPS22DF over I2C.
pub struct Lps22df<I2C> {
    state: AtomicState,
    label: Option<&'static str>,
    i2c: OnceLock<Mutex<CriticalSectionRawMutex, I2C>>,
    address: AtomicU8,
    pressure_offset: AtomicI16,
    signaling: Signal<CriticalSectionRawMutex, ()>,
    reading: ReadingSignal<ReadingResult<Samples>>,
}

impl<I2C: I2c + Send> Lps22df<I2C> {
    /// Creates an uninitialized driver.
    #[must_use]
    pub const fn new(label: Option<&'static str>) -> Self {
        Self {
            state: AtomicState::new(State::Uninitialized),
            label,
            i2c: OnceLock::new(),
            address: AtomicU8::new(I2cAddress::Sa0Vdd as u8),
            pressure_offset: AtomicI16::new(0),
            signaling: Signal::new(),
            reading: ReadingSignal::new(),
        }
    }

    /// Initializes the driver.
    pub async fn init(
        &'static self,
        _peripherals: Peripherals,
        mut i2c_device: I2C,
        config: Config,
    ) {
        if !self.i2c.is_set() {
            self.address.store(config.address as u8, Ordering::Release);

            match Self::reset(&mut i2c_device, config.address).await {
                Ok(pressure_offset) => {
                    self.pressure_offset
                        .store(pressure_offset, Ordering::Release);
                }
                Err(()) => return,
            }

            let _ = self.i2c.init(Mutex::new(i2c_device));

            self.state.set(State::Enabled);
        }
    }

    /// Resets the sensor device.
    ///
    /// # Errors
    ///
    /// Returns `Err(())` in case of a communication error with the sensor device.
    async fn reset(i2c_device: &mut I2C, address: I2cAddress) -> Result<i16, ()> {
        let address = address as u8;

        i2c_device
            .write(address, &[Register::CtrlReg2 as u8, crate::SWRESET_BITS])
            .await
            .map_err(|_| ())?;

        // Software reset can take a few tens of microseconds (AN5699 §6).
        Timer::after_micros(100).await;

        let mut buf = [0u8; 2];
        i2c_device
            .write_read(address, &[Register::RpdsL as u8], &mut buf)
            .await
            .map_err(|_| ())?;

        let pressure_offset = i16::from_be_bytes([buf[1], buf[0]]);

        Ok(pressure_offset)
    }

    /// Listens for measurement requests generated by [`Lps22df::trigger_measurement()`], and
    /// responds to them.
    /// This should be called before [`Lps22df::wait_for_reading()`], as that method will otherwise
    /// not be able to respond to measurement requests from [`Lps22df::trigger_measurement()`].
    ///
    /// # Note
    ///
    /// [`Lps22df::init()`] needs to be called and `await`ed before calling this method.
    pub async fn run(&'static self) -> ! {
        loop {
            self.signaling.wait().await;

            self.reading.signal(self.measure().await);
        }
    }

    /// Triggers a measurement and asynchronously returns the readings when available.
    ///
    /// # Errors
    ///
    /// Returns `ReadingError::SensorAccess` in case of a communication error with the sensor
    /// device.
    async fn measure(&'static self) -> ReadingResult<Samples> {
        let mut i2c = self.i2c.get().await.lock().await;
        let address = self.address.load(Ordering::Acquire);

        // Trigger a one-shot measurement.
        let ctrl = crate::BDU_BITS | crate::ONESHOT_BITS;
        i2c.write(address, &[Register::CtrlReg2 as u8, ctrl])
            .await
            .map_err(|_| ReadingError::SensorAccess)?;

        // Wait for the measurement.
        loop {
            // See Table 3 of AN5699 (AVG is zero by default).
            Timer::after_micros(1500).await;

            let mut buf = [0u8];
            i2c.write_read(address, &[Register::Status as u8], &mut buf)
                .await
                .map_err(|_| ReadingError::SensorAccess)?;

            // New data available.
            let mask = crate::T_DA_BITS | crate::P_DA_BITS;
            if buf[0] & mask == mask {
                break;
            }
        }

        // Requires `IF_ADD_INC` to be set (which is the default).
        let mut buf = [0u8; 5];
        i2c.write_read(address, &[Register::PressOutXl as u8], &mut buf)
            .await
            .map_err(|_| ReadingError::SensorAccess)?;

        let pressure = i32::from(self.pressure_offset.load(Ordering::Acquire))
            + i32_from_i24_be_bytes([buf[2], buf[1], buf[0]]) / crate::PRESSURE_SENSITIVITY;
        let temperature = i32::from(i16::from_be_bytes([buf[4], buf[3]]));

        let pressure_accuracy = crate::pressure_accuracy(pressure);
        let pressure_sample = Sample::new(pressure, pressure_accuracy);

        let temp_accuracy = crate::temp_accuracy(temperature);
        let temp_sample = Sample::new(temperature, temp_accuracy);

        // An alternative variant of this driver could also decide not to expose the temperature,
        // as it is not the main physical quantity this sensor device measures and the measurement
        // accuracy is not that great (the temperature sensing element is likely primarily there to
        // be able to determine the pressure measurement accuracy as MEMS devices are affected by
        // temperature).
        let samples = Samples::from_2(self, [pressure_sample, temp_sample]);

        Ok(samples)
    }
}

impl<I2C: Send> Sensor for Lps22df<I2C> {
    fn trigger_measurement(&self) -> Result<(), TriggerMeasurementError> {
        self.reading.clear();

        match self.state.get() {
            State::Measuring => {}
            State::Enabled => {
                self.state.set(State::Measuring);
            }
            State::Uninitialized | State::Disabled | State::Sleeping => {
                return Err(TriggerMeasurementError::NonEnabled);
            }
        }

        self.signaling.signal(());

        Ok(())
    }

    fn wait_for_reading(&'static self) -> ReadingWaiter {
        match self.state.get() {
            State::Measuring => {
                self.state.set(State::Enabled);

                ReadingWaiter::new(self.reading.wait())
            }
            State::Enabled => ReadingWaiter::new_err(ReadingError::NotMeasuring),
            State::Uninitialized | State::Disabled | State::Sleeping => {
                ReadingWaiter::new_err(ReadingError::NonEnabled)
            }
        }
    }

    fn set_mode(&self, mode: SensorMode) -> Result<State, SetModeError> {
        let new_state = self.state.set_mode(mode);

        if new_state == State::Uninitialized {
            Err(SetModeError::Uninitialized)
        } else {
            Ok(new_state)
        }
    }

    fn state(&self) -> State {
        self.state.get()
    }

    fn categories(&self) -> &'static [Category] {
        &[Category::Pressure, Category::PressureTemperature]
    }

    fn reading_channels(&self) -> ReadingChannels {
        #[expect(
            clippy::cast_possible_truncation,
            reason = "`i8::try_from()` is not yet usable in const contexts"
        )]
        const TEMP_SCALING: i8 = -(crate::TEMP_SENSITIVITY.ilog10() as i8);

        ReadingChannels::from([
            ReadingChannel::new(
                Label::Pressure,
                2, // h(Pa)
                MeasurementUnit::Pascal,
            ),
            ReadingChannel::new(Label::Temperature, TEMP_SCALING, MeasurementUnit::Celsius),
        ])
    }

    fn label(&self) -> Option<&'static str> {
        self.label
    }

    fn display_name(&self) -> Option<&'static str> {
        Some("pressure sensor")
    }

    fn part_number(&self) -> Option<&'static str> {
        Some(PART_NUMBER)
    }

    fn version(&self) -> u8 {
        0
    }
}
