//! Driver for the sensor used over I2C.

use ariel_os_sensors::{
    Category, Label, MeasurementUnit, Sensor,
    sensor::{
        Mode as SensorMode, ReadingChannel, ReadingChannels, ReadingError, ReadingResult,
        ReadingWaiter, Sample, Samples, SetModeError, State, TriggerMeasurementError,
    },
    signal::Signal as ReadingSignal,
};
use ariel_os_sensors_utils::AtomicState;
use embassy_sync::{
    blocking_mutex::raw::CriticalSectionRawMutex, mutex::Mutex, once_lock::OnceLock, signal::Signal,
};
use embassy_time::Timer;
use embedded_hal_async::i2c::I2c;
use portable_atomic::{AtomicU8, Ordering};

use crate::{PART_NUMBER, Register};

/// I2C address of the sensor device.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
pub enum I2cAddress {
    /// The ADDR pin is pull high.
    AddrVdd = 0x70 >> 1,
    /// The ADDR pin is pull high through a 15 kΩ resistor.
    Addr15kOhm = 0x78 >> 1,
    /// The ADDR pin is pull high through a 56 kΩ resistor.
    Addr56kOhm = 0x7c >> 1,
    /// The ADDR pin is pull low.
    // No internal pull resistor on the ADDR pin, we pick an arbitrary default value.
    #[default]
    AddrGnd = 0x7e >> 1,
}

/// Configuration of the sensor driver and device.
#[derive(Debug, Default)]
#[non_exhaustive]
pub struct Config {
    /// I2C address to use.
    pub address: I2cAddress,
}

ariel_os_hal::define_peripherals!(
    /// Peripherals required by the sensor driver.
    Peripherals {}
);

/// Driver to use an STTS22H over I2C.
pub struct Stts22h<I2C> {
    state: AtomicState,
    label: Option<&'static str>,
    i2c: OnceLock<Mutex<CriticalSectionRawMutex, I2C>>,
    address: AtomicU8,
    signaling: Signal<CriticalSectionRawMutex, ()>,
    reading: ReadingSignal<ReadingResult<Samples>>,
}

impl<I2C: I2c + Send> Stts22h<I2C> {
    /// Creates an uninitialized driver.
    #[expect(clippy::new_without_default)]
    #[must_use]
    pub const fn new(label: Option<&'static str>) -> Self {
        Self {
            state: AtomicState::new(State::Uninitialized),
            label,
            i2c: OnceLock::new(),
            address: AtomicU8::new(I2cAddress::AddrVdd as u8),
            signaling: Signal::new(),
            reading: ReadingSignal::new(),
        }
    }

    /// Initializes the driver.
    pub async fn init(
        &'static self,
        _peripherals: Peripherals,
        mut i2c_device: I2C,
        config: Config,
    ) {
        if !self.i2c.is_set() {
            self.address.store(config.address as u8, Ordering::Release);

            if Self::reset(&mut i2c_device, config.address).await.is_err() {
                return;
            }

            let _ = self.i2c.init(Mutex::new(i2c_device));

            self.state.set(State::Enabled);
        }
    }

    async fn reset(i2c_device: &mut I2C, address: I2cAddress) -> Result<(), ()> {
        // Set IF_ADD_INC first to reset the thresholds registers in one transaction.
        i2c_device
            .write(
                address as u8,
                &[Register::CtrlRegAddr as u8, crate::IF_ADD_INC_BITS],
            )
            .await
            .map_err(|_| ())?;

        // Reset the temperature limits, disabling the threshold interrupts.
        i2c_device
            .write(address as u8, &[Register::TempHLimit as u8, 0x00, 0x00])
            .await
            .map_err(|_| ())?;

        Ok(())
    }

    /// Listens for measurement requests generated by [`Stts22h::trigger_measurement()`], and
    /// responds to them.
    /// This should be called before [`Stts22h::wait_for_reading()`], as that method will otherwise
    /// not be able to respond to measurement requests from [`Stts22h::trigger_measurement()`].
    ///
    /// # Note
    ///
    /// [`Stts22h::init()`] needs to be called and `await`ed before calling this method.
    pub async fn run(&'static self) -> ! {
        loop {
            self.signaling.wait().await;

            self.reading.signal(self.measure().await);
        }
    }

    async fn measure(&'static self) -> ReadingResult<Samples> {
        let mut i2c = self.i2c.get().await.lock().await;
        let address = self.address.load(Ordering::Acquire);

        // Sensor configuration.
        let mut ctrl = 0u8;
        ctrl |= crate::ONE_SHOT_BITS;
        ctrl |= crate::IF_ADD_INC_BITS;
        ctrl |= crate::BDU_BITS;

        // Trigger a one-shot measurement.
        i2c.write(address, &[Register::CtrlRegAddr as u8, ctrl])
            .await
            .map_err(|_| ReadingError::SensorAccess)?;

        // Wait for the measurement.
        loop {
            let mut buf = [0u8];
            i2c.write_read(address, &[Register::StatusRegAddr as u8], &mut buf)
                .await
                .map_err(|_| ReadingError::SensorAccess)?;

            // Not BUSY anymore.
            if buf[0] & crate::BUSY_BITS == 0 {
                break;
            }

            // TODO: configuration
            Timer::after_millis(10).await;
        }

        // Reads both temperature bytes thanks to IF_ADD_INC.
        let mut buf = [0u8; 2];
        i2c.write_read(address, &[Register::TempLOutRegAddr as u8], &mut buf)
            .await
            .map_err(|_| ReadingError::SensorAccess)?;

        let temp = i32::from(i16::from_be_bytes([buf[1], buf[0]]));

        let accuracy = crate::accuracy(temp);
        let sample = Sample::new(temp, accuracy);

        let samples = Samples::from_1(self, [sample]);

        Ok(samples)
    }
}

impl<I2C: Send> Sensor for Stts22h<I2C> {
    fn trigger_measurement(&self) -> Result<(), TriggerMeasurementError> {
        match self.state.get() {
            State::Measuring => {
                self.reading.clear();
            }
            State::Enabled => {
                self.state.set(State::Measuring);
            }
            State::Uninitialized | State::Disabled | State::Sleeping => {
                return Err(TriggerMeasurementError::NonEnabled);
            }
        }

        self.signaling.signal(());

        Ok(())
    }

    fn wait_for_reading(&'static self) -> ReadingWaiter {
        match self.state.get() {
            State::Measuring => {
                self.state.set(State::Enabled);

                ReadingWaiter::new(self.reading.wait())
            }
            State::Enabled => {
                return ReadingWaiter::new_err(ReadingError::NotMeasuring);
            }
            State::Uninitialized | State::Disabled | State::Sleeping => {
                return ReadingWaiter::new_err(ReadingError::NonEnabled);
            }
        }
    }

    fn set_mode(&self, mode: SensorMode) -> Result<State, SetModeError> {
        let new_state = self.state.set_mode(mode);

        if new_state == State::Uninitialized {
            Err(SetModeError::Uninitialized)
        } else {
            Ok(new_state)
        }
    }

    fn state(&self) -> State {
        self.state.get()
    }

    fn categories(&self) -> &'static [Category] {
        &[Category::Temperature]
    }

    fn reading_channels(&self) -> ReadingChannels {
        ReadingChannels::from([ReadingChannel::new(
            Label::Temperature,
            -2,
            MeasurementUnit::Celsius,
        )])
    }

    fn label(&self) -> Option<&'static str> {
        self.label
    }

    fn display_name(&self) -> Option<&'static str> {
        Some("temperature sensor")
    }

    fn part_number(&self) -> Option<&'static str> {
        Some(PART_NUMBER)
    }

    fn version(&self) -> u8 {
        0
    }
}
