//! Driver for the sensor used over I2C.

use ariel_os_sensors::{
    Category, Label, MeasurementUnit, Sensor,
    sensor::{
        Mode as SensorMode, ReadingChannel, ReadingChannels, ReadingError, ReadingResult,
        ReadingWaiter, Sample, Samples, SetModeError, State, TriggerMeasurementError,
    },
    signal::Signal as ReadingSignal,
};
use ariel_os_sensors_utils::AtomicState;
use embassy_sync::{
    blocking_mutex::raw::CriticalSectionRawMutex, mutex::Mutex, once_lock::OnceLock, signal::Signal,
};
use embassy_time::Timer;
use embedded_hal_async::i2c::I2c;
use portable_atomic::{AtomicU8, Ordering};

use crate::{PART_NUMBER, Register};

/// I2C address of the sensor device.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
pub enum I2cAddress {
    /// The ADDR pin is pull high.
    AddrVdd = 0x70 >> 1,
    /// The ADDR pin is pull high through a 15 kΩ resistor.
    Addr15kOhm = 0x78 >> 1,
    /// The ADDR pin is pull high through a 56 kΩ resistor.
    Addr56kOhm = 0x7c >> 1,
    /// The ADDR pin is pull low.
    // No internal pull resistor on the ADDR pin, we pick an arbitrary default value.
    #[default]
    AddrGnd = 0x7e >> 1,
}

/// Configuration of the sensor driver and device.
#[derive(Debug, Default)]
#[non_exhaustive]
pub struct Config {
    /// I2C address to use.
    pub address: I2cAddress,
}

ariel_os_hal::define_peripherals!(
    /// Peripherals required by the sensor driver.
    Peripherals {}
);

/// Driver to use an STTS22H over I2C.
pub struct Stts22h<I2C> {
    state: AtomicState,
    label: Option<&'static str>,
    i2c: OnceLock<Mutex<CriticalSectionRawMutex, I2C>>,
    address: AtomicU8,
    signaling: Signal<CriticalSectionRawMutex, ()>,
    reading: ReadingSignal<ReadingResult<Samples>>,
}

impl<I2C: I2c + Send> Stts22h<I2C> {
    /// Creates an uninitialized driver.
    #[expect(clippy::new_without_default)]
    #[must_use]
    pub const fn new(label: Option<&'static str>) -> Self {
        Self {
            state: AtomicState::new(State::Uninitialized),
            label,
            i2c: OnceLock::new(),
            address: AtomicU8::new(I2cAddress::AddrVdd as u8),
            signaling: Signal::new(),
            reading: ReadingSignal::new(),
        }
    }

    /// Initializes the driver.
    pub async fn init(
        &'static self,
        _peripherals: Peripherals,
        mut i2c_device: I2C,
        config: Config,
    ) {
        if !self.i2c.is_set() {
            self.address.store(config.address as u8, Ordering::Release);

            if Self::reset(&mut i2c_device, config.address).await.is_err() {
                return;
            }

            let _ = self.i2c.init(Mutex::new(i2c_device));

            self.state.set(State::Enabled);
        }
    }

    async fn reset(i2c_device: &mut I2C, address: I2cAddress) -> Result<(), ()> {
        // Set IF_ADD_INC first to reset the thresholds registers in one transaction.
        i2c_device
            .write(
                address as u8,
                &[Register::CtrlRegAddr as u8, crate::IF_ADD_INC_BITS],
            )
            .await
            .map_err(|_| ())?;

        // Reset the temperature limits, disabling the threshold interrupts.
        i2c_device
            .write(address as u8, &[Register::TempHLimit as u8, 0x00, 0x00])
            .await
            .map_err(|_| ())?;

        Ok(())
    }

    /// Listens for measurement requests generated by [`Stts22h::trigger_measurement()`], and
    /// responds to them.
    /// This should be called before [`Stts22h::wait_for_reading()`], as that method will otherwise
    /// not be able to respond to measurement requests from [`Stts22h::trigger_measurement()`].
    ///
    /// # Note
    ///
    /// [`Stts22h::init()`] needs to be called and `await`ed before calling this method.
    pub async fn run(&'static self) -> ! {
        loop {
            self.signaling.wait().await;

            self.reading.signal(self.measure().await);
        }
    }

    async fn measure(&'static self) -> ReadingResult<Samples> {
        let mut i2c = self.i2c.get().await.lock().await;
        let address = self.address.load(Ordering::Acquire);

        // Sensor configuration.
        let mut ctrl = 0u8;
        ctrl |= crate::ONE_SHOT_BITS;
        ctrl |= crate::IF_ADD_INC_BITS;
        ctrl |= crate::BDU_BITS;

        // Trigger a one-shot measurement.
        i2c.write(address, &[Register::CtrlRegAddr as u8, ctrl])
            .await
            .map_err(|_| ReadingError::SensorAccess)?;

        // Wait for the measurement.
        loop {
            let mut buf = [0u8];
            i2c.write_read(address, &[Register::StatusRegAddr as u8], &mut buf)
                .await
                .map_err(|_| ReadingError::SensorAccess)?;

            // Not BUSY anymore.
            if buf[0] & crate::BUSY_BITS == 0 {
                break;
            }

            // TODO: configuration
            Timer::after_millis(10).await;
        }

        // Reads both temperature bytes thanks to IF_ADD_INC.
        let mut buf = [0u8; 2];
        i2c.write_read(address, &[Register::TempLOutRegAddr as u8], &mut buf)
            .await
            .map_err(|_| ReadingError::SensorAccess)?;

        let temp = i32::from(i16::from_be_bytes([buf[1], buf[0]]));

        let accuracy = crate::accuracy(temp);
        let sample = Sample::new(temp, accuracy);

        let samples = Samples::from_1(self, [sample]);

        Ok(samples)
    }
}

impl<I2C: Send> Sensor for Stts22h<I2C> {
    fn trigger_measurement(&self) -> Result<(), TriggerMeasurementError> {
        self.reading.clear();

        match self.state.get() {
            State::Measuring => {}
            State::Enabled => {
                self.state.set(State::Measuring);
            }
            State::Uninitialized | State::Disabled | State::Sleeping => {
                return Err(TriggerMeasurementError::NonEnabled);
            }
        }

        self.signaling.signal(());

        Ok(())
    }

    fn wait_for_reading(&'static self) -> ReadingWaiter {
        match self.state.get() {
            State::Measuring => {
                self.state.set(State::Enabled);

                ReadingWaiter::new(self.reading.wait())
            }
            State::Enabled => {
                return ReadingWaiter::new_err(ReadingError::NotMeasuring);
            }
            State::Uninitialized | State::Disabled | State::Sleeping => {
                return ReadingWaiter::new_err(ReadingError::NonEnabled);
            }
        }
    }

    fn set_mode(&self, mode: SensorMode) -> Result<State, SetModeError> {
        let new_state = self.state.set_mode(mode);

        if new_state == State::Uninitialized {
            Err(SetModeError::Uninitialized)
        } else {
            Ok(new_state)
        }
    }

    fn state(&self) -> State {
        self.state.get()
    }

    fn categories(&self) -> &'static [Category] {
        &[Category::Temperature]
    }

    fn reading_channels(&self) -> ReadingChannels {
        ReadingChannels::from([ReadingChannel::new(
            Label::Temperature,
            -2,
            MeasurementUnit::Celsius,
        )])
    }

    fn label(&self) -> Option<&'static str> {
        self.label
    }

    fn display_name(&self) -> Option<&'static str> {
        Some("temperature sensor")
    }

    fn part_number(&self) -> Option<&'static str> {
        Some(PART_NUMBER)
    }

    fn version(&self) -> u8 {
        0
    }
}

#[cfg(test)]
mod tests {
    use embedded_hal_async::i2c::{ErrorKind, Operation};

    use super::*;

    #[derive(Debug)]
    enum Error {}

    impl embedded_hal_async::i2c::Error for Error {
        fn kind(&self) -> ErrorKind {
            ErrorKind::Other
        }
    }

    #[derive(Default)]
    struct I2cDeviceMock {
        reading_count: usize,
    }

    impl embedded_hal_async::i2c::ErrorType for I2cDeviceMock {
        type Error = Error;
    }

    impl I2c for I2cDeviceMock {
        async fn transaction(
            &mut self,
            _address: embedded_hal_async::i2c::SevenBitAddress,
            operations: &mut [Operation<'_>],
        ) -> Result<(), Self::Error> {
            match operations {
                [Operation::Write(wbuf), Operation::Read(rbuf)] => match wbuf[0] {
                    addr if addr == Register::StatusRegAddr as u8 => {}
                    addr if addr == Register::TempLOutRegAddr as u8 => {
                        // Provide different samples for consecutive readings.
                        let sample: i32 = match self.reading_count {
                            0 => 2500,
                            1 => 1800,
                            _ => panic!("too many readings"),
                        };
                        rbuf.copy_from_slice(&sample.to_le_bytes()[..rbuf.len()]);
                        self.reading_count += 1;
                    }
                    addr => {
                        panic!("unknown register: {addr:#x}")
                    }
                },
                _ => {}
            }

            Ok(())
        }
    }

    #[test]
    fn fetch_temperature_reading() {
        use ariel_os_sensors::{Reading, sensor::SampleMetadata};

        static STTS22H: Stts22h<I2cDeviceMock> = Stts22h::<I2cDeviceMock>::new(Some("label"));

        init_sensor(&STTS22H);

        embassy_futures::block_on(async {
            embassy_futures::select::select(STTS22H.run(), async {
                STTS22H.trigger_measurement().unwrap();

                let reading = STTS22H.wait_for_reading().await.unwrap();
                let (channel, sample) = reading.sample();

                assert_eq!(channel.label(), Label::Temperature);

                assert_eq!(sample.value(), Ok(2500));
                assert_eq!(
                    sample.metadata(),
                    SampleMetadata::SymmetricalError {
                        deviation: 50,
                        bias: 0,
                        scaling: -2,
                    }
                );

                STTS22H.trigger_measurement().unwrap();

                let reading = STTS22H.wait_for_reading().await.unwrap();
                let (_channel, sample) = reading.sample();

                assert_eq!(sample.value(), Ok(1800));
            })
            .await;
        });
    }

    #[test]
    fn awaited_before_triggered() {
        static STTS22H: Stts22h<I2cDeviceMock> = Stts22h::<I2cDeviceMock>::new(Some("label"));

        init_sensor(&STTS22H);

        embassy_futures::block_on(async {
            embassy_futures::select::select(STTS22H.run(), async {
                assert!(matches!(
                    STTS22H.wait_for_reading().await,
                    Err(ReadingError::NotMeasuring)
                ));
            })
            .await
        });
    }

    #[test]
    fn cleared_when_double_triggered() {
        use ariel_os_sensors::Reading;

        static STTS22H: Stts22h<I2cDeviceMock> = Stts22h::<I2cDeviceMock>::new(Some("label"));

        init_sensor(&STTS22H);

        embassy_futures::block_on(async {
            embassy_futures::select::select(STTS22H.run(), async {
                STTS22H.trigger_measurement().unwrap();

                // The mock reading counter does not get incremented otherwise.
                embassy_futures::yield_now().await;

                // Should clear the first reading.
                STTS22H.trigger_measurement().unwrap();

                let reading = STTS22H.wait_for_reading().await.unwrap();
                let (_channel, sample) = reading.sample();

                // Should return the second reading.
                assert_eq!(sample.value(), Ok(1800));
            })
            .await
        });
    }

    #[test]
    fn multiple_waiters() {
        use ReadingError::NotMeasuring;

        static STTS22H: Stts22h<I2cDeviceMock> = Stts22h::<I2cDeviceMock>::new(Some("label"));

        init_sensor(&STTS22H);

        embassy_futures::block_on(async {
            embassy_futures::select::select(STTS22H.run(), async {
                STTS22H.trigger_measurement().unwrap();

                let join = embassy_futures::join::join(
                    STTS22H.wait_for_reading(),
                    STTS22H.wait_for_reading(),
                )
                .await;
                // Exactly one of them must be `Ok` and the other `Err`.
                assert!(matches!(
                    join,
                    (Ok(_), Err(NotMeasuring)) | (Err(NotMeasuring), Ok(_))
                ));

                STTS22H.trigger_measurement().unwrap();

                let join = embassy_futures::join::join3(
                    STTS22H.wait_for_reading(),
                    STTS22H.wait_for_reading(),
                    STTS22H.wait_for_reading(),
                )
                .await;
                // Exactly one of them must be `Ok` and the others `Err`.
                assert!(matches!(
                    join,
                    (Ok(_), Err(NotMeasuring), Err(NotMeasuring))
                        | (Err(NotMeasuring), Ok(_), Err(NotMeasuring))
                        | (Err(NotMeasuring), Err(NotMeasuring), Ok(_))
                ));
            })
            .await
        });
    }

    #[test]
    fn cancel_safety() {
        use ariel_os_sensors::Reading;

        static STTS22H: Stts22h<I2cDeviceMock> = Stts22h::<I2cDeviceMock>::new(Some("label"));

        init_sensor(&STTS22H);

        embassy_futures::block_on(async {
            embassy_futures::select::select(STTS22H.run(), async {
                STTS22H.trigger_measurement().unwrap();

                // The mock reading counter does not get incremented otherwise.
                embassy_futures::yield_now().await;

                let waiter = STTS22H.wait_for_reading();
                // Cancel the Future.
                drop(waiter);

                STTS22H.trigger_measurement().unwrap();

                let reading = STTS22H.wait_for_reading().await.unwrap();
                let (_channel, sample) = reading.sample();

                assert_eq!(sample.value(), Ok(1800));
            })
            .await
        });
    }

    fn init_sensor(stts22h: &'static Stts22h<I2cDeviceMock>) {
        embassy_futures::block_on(async {
            let peripherals = Peripherals {};
            let i2c_device = I2cDeviceMock::default();
            let config = Config::default();

            stts22h.init(peripherals, i2c_device, config).await;
        });
    }
}
