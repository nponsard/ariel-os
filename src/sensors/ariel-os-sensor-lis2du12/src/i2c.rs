//! Driver for the sensor used over I2C.

use ariel_os_sensors::{
    Category, Label, MeasurementUnit, Sensor,
    sensor::{
        Mode as SensorMode, ReadingChannel, ReadingChannels, ReadingError, ReadingResult,
        ReadingWaiter, Sample, Samples, SetModeError, State, TriggerMeasurementError,
    },
    signal::Signal as ReadingSignal,
};
use ariel_os_sensors_utils::AtomicState;
use embassy_sync::{
    blocking_mutex::raw::CriticalSectionRawMutex, mutex::Mutex, once_lock::OnceLock, signal::Signal,
};
use embassy_time::Timer;
use embedded_hal_async::i2c::I2c;
use portable_atomic::{AtomicU8, Ordering};

use crate::{AccelFullScale, PART_NUMBER, Register};

/// I2C address of the sensor device.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
pub enum I2cAddress {
    /// The SA0 pin is pulled low.
    Sa0Gnd = 0b0011000,
    /// The SA0 pin is pulled high.
    #[default]
    Sa0Vdd = 0b0011001,
}

/// Configuration of the sensor driver and device.
#[derive(Debug, Default)]
#[non_exhaustive]
pub struct Config {
    /// I2C address to use.
    pub address: I2cAddress,
}

ariel_os_hal::define_peripherals!(
    /// Peripherals required by the sensor driver.
    Peripherals {}
);

/// Driver to use an LIS2DU12 over I2C.
pub struct Lis2du12<I2C> {
    state: AtomicState,
    label: Option<&'static str>,
    i2c: OnceLock<Mutex<CriticalSectionRawMutex, I2C>>,
    address: AtomicU8,
    full_scale: AccelFullScale,
    signaling: Signal<CriticalSectionRawMutex, ()>,
    reading: ReadingSignal<ReadingResult<Samples>>,
}

impl<I2C: I2c + Send> Lis2du12<I2C> {
    /// Creates an uninitialized driver.
    #[expect(clippy::new_without_default)]
    #[must_use]
    pub const fn new(label: Option<&'static str>) -> Self {
        Self {
            state: AtomicState::new(State::Uninitialized),
            label,
            i2c: OnceLock::new(),
            address: AtomicU8::new(I2cAddress::Sa0Vdd as u8),
            full_scale: AccelFullScale::_2g,
            signaling: Signal::new(),
            reading: ReadingSignal::new(),
        }
    }

    /// Initializes the driver.
    pub async fn init(
        &'static self,
        _peripherals: Peripherals,
        mut i2c_device: I2C,
        config: Config,
    ) {
        if !self.i2c.is_set() {
            self.address.store(config.address as u8, Ordering::Release);

            // TODO: allow to select the full-scale.

            if Self::reset(&mut i2c_device, config.address).await.is_err() {
                return;
            }

            let _ = self.i2c.init(Mutex::new(i2c_device));

            self.state.set(State::Enabled);
        }
    }

    async fn reset(i2c_device: &mut I2C, address: I2cAddress) -> Result<(), ()> {
        let address = address as u8;

        // The device is always in power-down mode as we are only using the one-shot mode.
        i2c_device
            .write(address, &[Register::Ctrl1Addr as u8, crate::SW_RESET])
            .await
            .map_err(|_| ())?;

        // Initial sensor configuration.
        {
            // Enable address auto-increment on serial interface.
            let ctrl = crate::IF_ADD_INC_BITS;
            i2c_device
                .write(address, &[Register::Ctrl1Addr as u8, ctrl])
                .await
                .map_err(|_| ())?;

            let ctrl = crate::Odr::OneShotInterface as u8;
            i2c_device
                .write(address, &[Register::Ctrl5Addr as u8, ctrl])
                .await
                .map_err(|_| ())?;
        }

        Ok(())
    }

    /// Listens for measurement requests generated by [`Lis2du12::trigger_measurement()`], and
    /// responds to them.
    /// This should be called before [`Lis2du12::wait_for_reading()`], as that method will
    /// otherwise not be able to respond to measurement requests from
    /// [`Lis2du12::trigger_measurement()`].
    ///
    /// # Note
    ///
    /// [`Lis2du12::init()`] needs to be called and `await`ed before calling this method.
    pub async fn run(&'static self) -> ! {
        loop {
            self.signaling.wait().await;

            self.reading.signal(self.measure().await);
        }
    }

    async fn measure(&'static self) -> ReadingResult<Samples> {
        let mut i2c = self.i2c.get().await.lock().await;
        let address = self.address.load(Ordering::Acquire);

        // Trigger acceleration measurement.
        let ctrl = crate::BDU_BITS | crate::SOC_BITS;
        i2c.write(address, &[Register::Ctrl4Addr as u8, ctrl])
            .await
            .map_err(|_| ReadingError::SensorAccess)?;

        // Wait for the measurement.
        loop {
            let mut buf = [0u8];
            i2c.write_read(address, &[Register::StatusAddr as u8], &mut buf)
                .await
                .map_err(|_| ReadingError::SensorAccess)?;

            // New data available.
            let mask = crate::DRDY_BITS;
            if buf[0] & mask == mask {
                break;
            }

            // TODO: configuration
            Timer::after_millis(10).await;
        }

        // Read all acceleration registers.
        let mut buf = [0u8; 3 * 2];
        i2c.write_read(address, &[Register::OutXLAddr as u8], &mut buf)
            .await
            .map_err(|_| ReadingError::SensorAccess)?;

        let accel_x = self
            .full_scale
            .from_lsb_to_microg(i16::from_be_bytes([buf[1], buf[0]]));
        let accel_y = self
            .full_scale
            .from_lsb_to_microg(i16::from_be_bytes([buf[3], buf[2]]));
        let accel_z = self
            .full_scale
            .from_lsb_to_microg(i16::from_be_bytes([buf[5], buf[4]]));

        let accel_accuracy = crate::accel_accuracy();

        let samples = Samples::from_3(
            self,
            [
                Sample::new(accel_x, accel_accuracy),
                Sample::new(accel_y, accel_accuracy),
                Sample::new(accel_z, accel_accuracy),
            ],
        );

        Ok(samples)
    }
}

impl<I2C: Send> Sensor for Lis2du12<I2C> {
    fn trigger_measurement(&self) -> Result<(), TriggerMeasurementError> {
        self.reading.clear();

        match self.state.get() {
            State::Measuring => {}
            State::Enabled => {
                self.state.set(State::Measuring);
            }
            State::Uninitialized | State::Disabled | State::Sleeping => {
                return Err(TriggerMeasurementError::NonEnabled);
            }
        }

        self.signaling.signal(());

        Ok(())
    }

    fn wait_for_reading(&'static self) -> ReadingWaiter {
        match self.state.get() {
            State::Measuring => {
                self.state.set(State::Enabled);

                ReadingWaiter::new(self.reading.wait())
            }
            State::Enabled => {
                return ReadingWaiter::new_err(ReadingError::NotMeasuring);
            }
            State::Uninitialized | State::Disabled | State::Sleeping => {
                return ReadingWaiter::new_err(ReadingError::NonEnabled);
            }
        }
    }

    fn set_mode(&self, mode: SensorMode) -> Result<State, SetModeError> {
        let new_state = self.state.set_mode(mode);

        if new_state == State::Uninitialized {
            Err(SetModeError::Uninitialized)
        } else {
            Ok(new_state)
        }
    }

    fn state(&self) -> State {
        self.state.get()
    }

    fn categories(&self) -> &'static [Category] {
        &[Category::Accelerometer]
    }

    fn reading_channels(&self) -> ReadingChannels {
        ReadingChannels::from([
            ReadingChannel::new(Label::AccelerationX, -6, MeasurementUnit::AccelG),
            ReadingChannel::new(Label::AccelerationY, -6, MeasurementUnit::AccelG),
            ReadingChannel::new(Label::AccelerationZ, -6, MeasurementUnit::AccelG),
        ])
    }

    fn label(&self) -> Option<&'static str> {
        self.label
    }

    fn display_name(&self) -> Option<&'static str> {
        Some("3-axis accelerometer")
    }

    fn part_number(&self) -> Option<&'static str> {
        Some(PART_NUMBER)
    }

    fn version(&self) -> u8 {
        0
    }
}
