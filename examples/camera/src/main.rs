#![no_main]
#![no_std]

mod pins;
use core::cell::RefCell;

use ariel_os::gpio::Level;
use ariel_os::gpio::Output;
use ariel_os::time::Timer;
use ariel_os::{
    debug::log::info,
    hal,
    i2c::controller::{Kilohertz, highest_freq_in},
};
use embedded_hal_async::i2c::I2c;
use esp_hal::dma_rx_stream_buffer;
use esp_hal::lcd_cam::{
    LcdCam,
    cam::{Camera, Config, RxEightBits},
};
use fugit::{HertzU32, MegahertzU32};

// https://github.com/rursprung/esp32-cam-test/blob/main/src/ov2640.rs

const FIRST_BLOCK: &[(u8, u8)] = &[(0xFF, 0x01), (0x12, 0x80)];

const SECOND_BLOCK: &[(u8, u8)] = &[
    (0xFF, 0x00),
    (0x2C, 0xFF),
    (0x2E, 0xDF),
    (0xFF, 0x01),
    (0x3C, 0x32),
    (0x11, 0x01),
    (0x09, 0x02),
    (0x04, 0x28),
    (0x13, 0xE5),
    (0x14, 0x48),
    (0x2C, 0x0C),
    (0x33, 0x78),
    (0x3A, 0x33),
    (0x3B, 0xFB),
    (0x3E, 0x00),
    (0x43, 0x11),
    (0x16, 0x10),
    (0x39, 0x92),
    (0x35, 0xDA),
    (0x22, 0x1A),
    (0x37, 0xC3),
    (0x23, 0x00),
    (0x34, 0xC0),
    (0x06, 0x88),
    (0x07, 0xC0),
    (0x0D, 0x87),
    (0x0E, 0x41),
    (0x4C, 0x00),
    (0x4A, 0x81),
    (0x21, 0x99),
    (0x24, 0x40),
    (0x25, 0x38),
    (0x26, 0x82),
    (0x5C, 0x00),
    (0x63, 0x00),
    (0x61, 0x70),
    (0x62, 0x80),
    (0x7C, 0x05),
    (0x20, 0x80),
    (0x28, 0x30),
    (0x6C, 0x00),
    (0x6D, 0x80),
    (0x6E, 0x00),
    (0x70, 0x02),
    (0x71, 0x94),
    (0x73, 0xC1),
    (0x3D, 0x34),
    (0x5A, 0x57),
    (0x4F, 0xBB),
    (0x50, 0x9C),
    (0x12, 0x20),
    (0x17, 0x11),
    (0x18, 0x43),
    (0x19, 0x00),
    (0x1A, 0x25),
    (0x32, 0x89),
    (0x37, 0xC0),
    (0x4F, 0xCA),
    (0x50, 0xA8),
    (0x6D, 0x00),
    (0x3D, 0x38),
    (0xFF, 0x00),
    (0xE5, 0x7F),
    (0xF9, 0xC0),
    (0x41, 0x24),
    (0xE0, 0x14),
    (0x76, 0xFF),
    (0x33, 0xA0),
    (0x42, 0x20),
    (0x43, 0x18),
    (0x4C, 0x00),
    (0x87, 0x50),
    (0x88, 0x3F),
    (0xD7, 0x03),
    (0xD9, 0x10),
    (0xD3, 0x82),
    (0xC8, 0x08),
    (0xC9, 0x80),
    (0x7C, 0x00),
    (0x7D, 0x00),
    (0x7C, 0x03),
    (0x7D, 0x48),
    (0x7D, 0x48),
    (0x7C, 0x08),
    (0x7D, 0x20),
    (0x7D, 0x10),
    (0x7D, 0x0E),
    (0x90, 0x00),
    (0x91, 0x0E),
    (0x91, 0x1A),
    (0x91, 0x31),
    (0x91, 0x5A),
    (0x91, 0x69),
    (0x91, 0x75),
    (0x91, 0x7E),
    (0x91, 0x88),
    (0x91, 0x8F),
    (0x91, 0x96),
    (0x91, 0xA3),
    (0x91, 0xAF),
    (0x91, 0xC4),
    (0x91, 0xD7),
    (0x91, 0xE8),
    (0x91, 0x20),
    (0x92, 0x00),
    (0x93, 0x06),
    (0x93, 0xE3),
    (0x93, 0x05),
    (0x93, 0x05),
    (0x93, 0x00),
    (0x93, 0x04),
    (0x93, 0x00),
    (0x93, 0x00),
    (0x93, 0x00),
    (0x93, 0x00),
    (0x93, 0x00),
    (0x93, 0x00),
    (0x93, 0x00),
    (0x96, 0x00),
    (0x97, 0x08),
    (0x97, 0x19),
    (0x97, 0x02),
    (0x97, 0x0C),
    (0x97, 0x24),
    (0x97, 0x30),
    (0x97, 0x28),
    (0x97, 0x26),
    (0x97, 0x02),
    (0x97, 0x98),
    (0x97, 0x80),
    (0x97, 0x00),
    (0x97, 0x00),
    (0xA4, 0x00),
    (0xA8, 0x00),
    (0xC5, 0x11),
    (0xC6, 0x51),
    (0xBF, 0x80),
    (0xC7, 0x10),
    (0xB6, 0x66),
    (0xB8, 0xA5),
    (0xB7, 0x64),
    (0xB9, 0x7C),
    (0xB3, 0xAF),
    (0xB4, 0x97),
    (0xB5, 0xFF),
    (0xB0, 0xC5),
    (0xB1, 0x94),
    (0xB2, 0x0F),
    (0xC4, 0x5C),
    (0xC3, 0xFD),
    (0x7F, 0x00),
    (0xE5, 0x1F),
    (0xE1, 0x67),
    (0xDD, 0x7F),
    (0xDA, 0x00),
    (0xE0, 0x00),
    (0x05, 0x00),
    (0x05, 0x01),
    (0xFF, 0x01),
    (0x12, 0x40),
    (0x03, 0x0A),
    (0x32, 0x09),
    (0x17, 0x11),
    (0x18, 0x43),
    (0x19, 0x00),
    (0x1A, 0x4B),
    (0x37, 0xC0),
    (0x4F, 0xCA),
    (0x50, 0xA8),
    (0x5A, 0x23),
    (0x6D, 0x00),
    (0x3D, 0x38),
    (0x39, 0x92),
    (0x35, 0xDA),
    (0x22, 0x1A),
    (0x37, 0xC3),
    (0x23, 0x00),
    (0x34, 0xC0),
    (0x06, 0x88),
    (0x07, 0xC0),
    (0x0D, 0x87),
    (0x0E, 0x41),
    (0x42, 0x03),
    (0x4C, 0x00),
    (0xFF, 0x00),
    (0xE0, 0x04),
    (0xC0, 0x64),
    (0xC1, 0x4B),
    (0x8C, 0x00),
    (0x51, 0xC8),
    (0x52, 0x96),
    (0x53, 0x00),
    (0x54, 0x00),
    (0x55, 0x00),
    (0x57, 0x00),
    (0x86, 0x3D),
    (0x50, 0x80),
    (0x51, 0xC8),
    (0x52, 0x96),
    (0x53, 0x00),
    (0x54, 0x00),
    (0x55, 0x00),
    (0x57, 0x00),
    (0x5A, 0xA0),
    (0x5B, 0x78),
    (0x5C, 0x00),
    (0xFF, 0x01),
    (0x11, 0x00),
    (0xFF, 0x00),
    (0xD3, 0x10),
    (0x05, 0x00),
    (0xE0, 0x14),
    (0xDA, 0x12),
    (0xD7, 0x03),
    (0xE1, 0x77),
    (0xE5, 0x1F),
    (0xD9, 0x10),
    (0xDF, 0x80),
    (0x33, 0x80),
    (0x3C, 0x10),
    (0xEB, 0x30),
    (0xDD, 0x7F),
    (0xE0, 0x00),
    (0xE0, 0x14),
    (0xDA, 0x12),
    (0xD7, 0x03),
    (0xE1, 0x77),
    (0xE5, 0x1F),
    (0xD9, 0x10),
    (0xDF, 0x80),
    (0x33, 0x80),
    (0x3C, 0x10),
    (0xEB, 0x30),
    (0xDD, 0x7F),
    (0xE0, 0x00),
    (0xFF, 0x01),
    (0x14, 0x08),
    (0xFF, 0x00),
    (0x87, 0x50),
    (0x87, 0x10),
    (0xC3, 0xFD),
    (0x44, 0x0C),
];

#[ariel_os::task(autostart, peripherals)]
async fn i2c_scanner(peripherals: pins::Peripherals) {
    let mut i2c_config = hal::i2c::controller::Config::default();
    // i2c_config.frequency = const { highest_freq_in(Kilohertz::kHz(90)..=Kilohertz::kHz(110)) };

    let mut i2c_bus = pins::SensorI2c::new(peripherals.i2c_sda, peripherals.i2c_scl, i2c_config);

    let lcd_cam = LcdCam::new(peripherals.lcd_cam);

    let mut config = Config::default();
    config.frequency = HertzU32::MHz(20);

    let camera = esp_hal::lcd_cam::cam::Camera::new(
        lcd_cam.cam,
        peripherals.dma_ch0,
        RxEightBits::new(
            peripherals.dvp_y2,
            peripherals.dvp_y3,
            peripherals.dvp_y4,
            peripherals.dvp_y5,
            peripherals.dvp_y6,
            peripherals.dvp_y7,
            peripherals.dvp_y8,
            peripherals.dvp_y9,
        ),
        config,
    )
    .unwrap()
    .with_master_clock(peripherals.xmclk)
    .with_pixel_clock(peripherals.dvp_pclk)
    .with_ctrl_pins(peripherals.dvp_vsync, peripherals.dvp_href);
    let dma_buf = dma_rx_stream_buffer!(64_000, 2000);

    info!("Checking for I2C devices on the bus...");

    let res = i2c_bus.write(0x30, &[0xFF, 0x01]).await;
    info!(
        "Attempted to write to address 0x30, result: {:?}",
        defmt::Debug2Format(&res)
    );
    let mut buf = [0u8; 1];
    let res = i2c_bus.write_read(0x30, &[0x0A], &mut buf).await;
    info!(
        "Attempted to read from address 0x30, result: {:?}, buf = {:?}",
        defmt::Debug2Format(&res),
        buf
    );

    for (reg, value) in FIRST_BLOCK {
        let res = i2c_bus.write(0x30, &[*reg, *value]).await;
        info!(
            "Writing to register 0x{:02X} with value 0x{:02X}, result: {:?}",
            reg,
            value,
            defmt::Debug2Format(&res)
        );
    }
    Timer::after_millis(10).await;

    for (reg, value) in SECOND_BLOCK {
        let res = i2c_bus.write(0x30, &[*reg, *value]).await;
        info!(
            "Writing to register 0x{:02X} with value 0x{:02X}, result: {:?}",
            reg,
            value,
            defmt::Debug2Format(&res)
        );
        if *reg == 0xDD && *value == 0x7F {
            Timer::after_millis(10).await;
        }
    }

    let mut led = Output::new(peripherals.user_led, Level::Low);

    let mut camera = Some(camera);
    let mut dma_buf = Some(dma_buf);

    loop {
        let camera_taken = camera.take().unwrap();
        let transfer = match camera_taken.receive(dma_buf.take().unwrap()) {
            Ok(transfer) => transfer,
            Err(e) => {
                info!("Failed to start camera transfer");
                return;
            }
        };
        while !transfer.is_done() {
            let (data, ends_with_eof) = transfer.peek_until_eof();
            info!(
                "Received {} bytes, ends with EOF: {}, is done: {}",
                data.len(),
                ends_with_eof,
                transfer.is_done()
            );
        }
        let (c, b) = transfer.stop();
        camera.replace(c);
        dma_buf.replace(b);
        led.toggle();
        info!("LED toggled");
        Timer::after_millis(500).await;
    }
}
